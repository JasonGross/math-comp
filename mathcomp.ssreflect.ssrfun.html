<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>mathcomp.ssreflect.ssrfun</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library mathcomp.ssreflect.ssrfun</h1>

<div class="code">
<span class="comment">(*&nbsp;(c)&nbsp;Copyright&nbsp;2006-2015&nbsp;Microsoft&nbsp;Corporation&nbsp;and&nbsp;Inria.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;Distributed&nbsp;under&nbsp;the&nbsp;terms&nbsp;of&nbsp;CeCILL-B.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*)</span><br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <a class="idref" href="mathcomp.ssreflect.ssreflect.html#"><span class="id" title="library">ssreflect</span></a>.<br/>

<br/>
</div>

<div class="doc">
 This file contains the basic definitions and notations for working with    
 functions. The definitions provide for:                                    

<div class="paragraph"> </div>

<ul class="doclist">
<li> Pair projections:                                                        
    p.1  == first element of a pair                                         
    p.2  == second element of a pair                                        
   These notations also apply to p : P /\ Q, via an and &gt;-&gt; pair coercion.  

<div class="paragraph"> </div>


</li>
<li> Simplifying functions, beta-reduced by /= and simpl:                     
           [fun : T =&gt; E] == constant function from type T that returns E   
             [fun x =&gt; E] == unary function                                 
         [fun x : T =&gt; E] == unary function with explicit domain type       
           [fun x y =&gt; E] == binary function                                
       [fun x y : T =&gt; E] == binary function with common domain type        
         [fun (x : T) y =&gt; E] \                                             

</li>
</ul>
 [fun (x : xT) (y : yT) =&gt; E] | == binary function with (some) explicit,    
         [fun x (y : T) =&gt; E] / independent domain types for each argument  

<div class="paragraph"> </div>

<ul class="doclist">
<li> Partial functions using option type:                                     
     oapp f d ox == if ox is Some x returns f x,        d otherwise         
      odflt d ox == if ox is Some x returns x,          d otherwise         
      obind f ox == if ox is Some x returns f x,        None otherwise      
       omap f ox == if ox is Some x returns Some (f x), None otherwise      

<div class="paragraph"> </div>


</li>
<li> Singleton types:                                                         
  all_equal_to x0 == x0 is the only value in its type, so any such value    
                     can be rewritten to x0.                                

<div class="paragraph"> </div>


</li>
<li> A generic wrapper type:                                                  
       wrapped T == the inductive type with values Wrap x for x : T.        
        unwrap w == the projection of w : wrapped T on T.                   
          wrap x == the canonical injection of x : T into wrapped T; it is  
                    equivalent to Wrap x, but is declared as a (default)    
                    Canonical Structure, which lets the Coq HO unification  
                    automatically expand x into unwrap (wrap x). The delta  
                    reduction of wrap x to Wrap can be exploited to         
                    introduce controlled nondeterminism in Canonical        
                    Structure inference, as in the implementation of        
                    the mxdirect predicate in matrix.v.                     

<div class="paragraph"> </div>


</li>
<li> Sigma types:                                                             
           tag w == the i of w : {i : I &amp; T i}.                             
        tagged w == the T i component of w : {i : I &amp; T i}.                 
      Tagged T x == the {i : I &amp; T i} with component x : T i.               
          tag2 w == the i of w : {i : I &amp; T i &amp; U i}.                       
       tagged2 w == the T i component of w : {i : I &amp; T i &amp; U i}.           
      tagged2' w == the U i component of w : {i : I &amp; T i &amp; U i}.           

</li>
</ul>
 Tagged2 T U x y == the {i : I &amp; T i} with components x : T i and y : U i.  
          sval u == the x of u : {x : T | P x}.                             
         s2val u == the x of u : {x : T | P x &amp; Q x}.                       
   The properties of sval u, s2val u are given by lemmas svalP, s2valP, and 
   s2valP'. We provide coercions sigT2 &gt;-&gt; sigT and sig2 &gt;-&gt; sig &gt;-&gt; sigT.  
   A suite of lemmas (all_sig, ...) let us skolemize sig, sig2, sigT, sigT2 
   and pair, e.g.,                                                          
     have /all_sig[f fP] (x : T): {y : U | P y} by ...                      
   yields an f : T -&gt; U such that fP : forall x, P (f x).                   

<div class="paragraph"> </div>

<ul class="doclist">
<li> Identity functions:                                                      
    id           == NOTATION for the explicit identity function fun x =&gt; x. 
    @id T        == notation for the explicit identity at type T.           
    idfun        == an expression with a head constant, convertible to id;  
                    idfun x simplifies to x.                                
    @idfun T     == the expression above, specialized to type T.            
    phant_id x y == the function type phantom _ x -&gt; phantom _ y.           

</li>
</ul>
 *** In addition to their casual use in functional programming, identity    
 functions are often used to trigger static unification as part of the      
 construction of dependent Records and Structures. For example, if we need  
 a structure sT over a type T, we take as arguments T, sT, and a "dummy"    
 function T -&gt; sort sT:                                                     
   Definition foo T sT &amp; T -&gt; sort sT := ...                                
 We can avoid specifying sT directly by calling foo (@id T), or specify     
 the call completely while still ensuring the consistency of T and sT, by   
 calling @foo T sT idfun. The phant_id type allows us to extend this trick  
 to non-Type canonical projections. It also allows us to sidestep           
 dependent type constraints when building explicit records, e.g., given     
    Record r := R {x; y : T(x)}.                                            
 if we need to build an r from a given y0 while inferring some x0, such     
 that y0 : T(x0), we pose                                                   
    Definition mk_r .. y .. (x := ...) y' &amp; phant_id y y' := R x y'.        
 Calling @mk_r .. y0 .. id will cause Coq to use y' := y0, while checking   
 the dependent type constraint y0 : T(x0).                                  

<div class="paragraph"> </div>

<ul class="doclist">
<li> Extensional equality for functions and relations (i.e. functions of two  
   arguments):                                                              
    f1 =1 f2      ==  f1 x is equal to f2 x for all x.                      
    f1 =1 f2 :&gt; A ==    ... and f2 is explicitly typed.                     
    f1 =2 f2      ==  f1 x y is equal to f2 x y for all x y.                
    f1 =2 f2 :&gt; A ==    ... and f2 is explicitly typed.                     

<div class="paragraph"> </div>


</li>
<li> Composition for total and partial functions:                             
            f^~ y == function f with second argument specialised to y,      
                     i.e., fun x =&gt; f x y                                   
                     CAVEAT: conditional (non-maximal) implicit arguments   
                     of f are NOT inserted in this context                  
            @^~ x == application at x, i.e., fun f =&gt; f x                   
          [eta f] == the explicit eta-expansion of f, i.e., fun x =&gt; f x    
                     CAVEAT: conditional (non-maximal) implicit arguments   
                     of f are NOT inserted in this context.                 
          fun=&gt; v := the constant function fun _ =&gt; v.                      
        f1 \o f2  == composition of f1 and f2.                              
                     Note: (f1 \o f2) x simplifies to f1 (f2 x).            
         f1 \; f2 == categorical composition of f1 and f2. This expands to  
                     to f2 \o f1 and (f1 \; f2) x simplifies to f2 (f1 x).  
      pcomp f1 f2 == composition of partial functions f1 and f2.            

<div class="paragraph"> </div>


</li>
<li> Reserved notation for various arithmetic and algebraic operations:       
     e. [a1, ..., a_n] evaluation (e.g., polynomials).                       
                 e`<i>i indexing (number list, integer pi-part).              
                 x^-1 inverse (group, field).                               
       x *+ n, x *- n integer multiplier (modules and rings).               
       x ^+ n, x ^- n integer exponent (groups and rings).                  
       x *: A, A :* x external product (scaling/module product in rings,    
                      left/right cosets in groups).                         
             A :&amp;: B  intersection (of sets, groups, subspaces, ...).       
     A :|: B, a |: B  union, union with a singleton (of sets).              
     A :\: B, A :\ b  relative complement (of sets, subspaces, ...).        
        <tt>A</tt>, &lt; [a]&gt;  generated group/subspace, generated cycle/line.       
       'C[x], 'C_A[x] point centralisers (in groups and F-algebras).        
       'C(A), 'C_B(A) centralisers (in groups and matrix and F_algebras).   
                'Z(A) centers (in groups and matrix and F-algebras).        
       m %/ d, m %% d Euclidean division and remainder (nat, polynomials).  
               d %| m Euclidean divisibility (nat, polynomial).             
       m = n % [mod d] equality mod d (also defined for &lt;&gt;, ==, and !=).     
               e^`(n) nth formal derivative (groups, polynomials).          
                e^` simple formal derivative (polynomials only).          
                 `|x| norm, absolute value, distance (rings, int, nat).     
      x &lt;= y ?= iff C x is less than y, and equal iff C holds (nat, rings). 
     x &lt;= y :&gt; T, etc cast comparison (rings, all comparison operators).    
    [rec a1, ..., an] standard shorthand for hidden recursor (see prime.v). 
   The interpretation of these notations is not defined here, but the       
   declarations help maintain consistency across the library.               

<div class="paragraph"> </div>


</li>
<li> Properties of functions:                                                 
      injective f &lt;-&gt; f is injective.                                       
       cancel f g &lt;-&gt; g is a left inverse of f / f is a right inverse of g. 
      pcancel f g &lt;-&gt; g is a left inverse of f where g is partial.          
      ocancel f g &lt;-&gt; g is a left inverse of f where f is partial.          
      bijective f &lt;-&gt; f is bijective (has a left and right inverse).        
     involutive f &lt;-&gt; f is involutive.                                      

<div class="paragraph"> </div>


</li>
<li> Properties for operations.                                               
              left_id e op &lt;-&gt; e is a left identity for op (e op x = x).    
             right_id e op &lt;-&gt; e is a right identity for op (x op e = x).   
     left_inverse e inv op &lt;-&gt; inv is a left inverse for op wrt identity e, 
                               i.e., (inv x) op x = e.                      
    right_inverse e inv op &lt;-&gt; inv is a right inverse for op wrt identity e 
                               i.e., x op (i x) = e.                        
         self_inverse e op &lt;-&gt; each x is its own op-inverse (x op x = e).   
             idempotent op &lt;-&gt; op is idempotent for op (x op x = x).        
              associative op &lt;-&gt; op is associative, i.e.,                   
                               x op (y op z) = (x op y) op z.               
            commutative op &lt;-&gt; op is commutative (x op y = y op x).         
       left_commutative op &lt;-&gt; op is left commutative, i.e.,                
                                   x op (y op z) = y op (x op z).           
      right_commutative op &lt;-&gt; op is right commutative, i.e.,               
                                   (x op y) op z = (x op z) op y.           
            left_zero z op &lt;-&gt; z is a left zero for op (z op x = z).        
           right_zero z op &lt;-&gt; z is a right zero for op (x op z = z).       
  left_distributive op1 op2 &lt;-&gt; op1 distributes over op2 to the left:       
                             (x op2 y) op1 z = (x op1 z) op2 (y op1 z).     

</li>
</ul>
 right_distributive op1 op2 &lt;-&gt; op distributes over add to the right:       
                             x op1 (y op2 z) = (x op1 z) op2 (x op1 z).     
        interchange op1 op2 &lt;-&gt; op1 and op2 satisfy an interchange law:     
                        (x op2 y) op1 (z op2 t) = (x op1 z) op2 (y op1 t).  
  Note that interchange op op is a commutativity property.                  
         left_injective op &lt;-&gt; op is injective in its left argument:        
                             x op y = z op y -&gt; x = z.                      
        right_injective op &lt;-&gt; op is injective in its right argument:       
                             x op y = x op z -&gt; y = z.                      
          left_loop inv op &lt;-&gt; op, inv obey the inverse loop left axiom:    
                              (inv x) op (x op y) = y for all x, y, i.e.,   
                              op (inv x) is always a left inverse of op x   
      rev_left_loop inv op &lt;-&gt; op, inv obey the inverse loop reverse left   
                              axiom: x op ((inv x) op y) = y, for all x, y. 
         right_loop inv op &lt;-&gt; op, inv obey the inverse loop right axiom:   
                              (x op y) op (inv y) = x for all x, y.         
     rev_right_loop inv op &lt;-&gt; op, inv obey the inverse loop reverse right  
                              axiom: (x op y) op (inv y) = x for all x, y.  
   Note that familiar "cancellation" identities like x + y - y = x or       
 x - y + x = x are respectively instances of right_loop and rev_right_loop  
 The corresponding lemmas will use the K and NK/VK suffixes, respectively.  

<div class="paragraph"> </div>

<ul class="doclist">
<li> Morphisms for functions and relations:                                   
    {morph f : x / a &gt;-&gt; r} &lt;-&gt; f is a morphism with respect to functions   
                               (fun x =&gt; a) and (fun x =&gt; r); if r == R[x], 
                               this states that f a = R[f x] for all x.     
          {morph f : x / a} &lt;-&gt; f is a morphism with respect to the         
                               function expression (fun x =&gt; a). This is    
                               shorthand for {morph f : x / a &gt;-&gt; a}; note  
                               that the two instances of a are often        
                               interpreted at different types.              
  {morph f : x y / a &gt;-&gt; r} &lt;-&gt; f is a morphism with respect to functions   
                               (fun x y =&gt; a) and (fun x y =&gt; r).           
        {morph f : x y / a} &lt;-&gt; f is a morphism with respect to the         
                               function expression (fun x y =&gt; a).          
     {homo f : x / a &gt;-&gt; r} &lt;-&gt; f is a homomorphism with respect to the     
                               predicates (fun x =&gt; a) and (fun x =&gt; r);    
                               if r == R[x], this states that a -&gt; R[f x]   
                               for all x.                                   
           {homo f : x / a} &lt;-&gt; f is a homomorphism with respect to the     
                               predicate expression (fun x =&gt; a).           
   {homo f : x y / a &gt;-&gt; r} &lt;-&gt; f is a homomorphism with respect to the     
                               relations (fun x y =&gt; a) and (fun x y =&gt; r). 
         {homo f : x y / a} &lt;-&gt; f is a homomorphism with respect to the     
                               relation expression (fun x y =&gt; a).          
     {mono f : x / a &gt;-&gt; r} &lt;-&gt; f is monotone with respect to projectors    
                               (fun x =&gt; a) and (fun x =&gt; r); if r == R[x], 
                               this states that R[f x] = a for all x.       
           {mono f : x / a} &lt;-&gt; f is monotone with respect to the projector 
                               expression (fun x =&gt; a).                     
   {mono f : x y / a &gt;-&gt; r} &lt;-&gt; f is monotone with respect to relators      
                               (fun x y =&gt; a) and (fun x y =&gt; r).           
         {mono f : x y / a} &lt;-&gt; f is monotone with respect to the relator   
                               expression (fun x y =&gt; a).                   

</li>
</ul>
 The file also contains some basic lemmas for the above concepts.           
 Lemmas relative to cancellation laws use some abbreviated suffixes:        
   K - a cancellation rule like esymK : cancel (@esym T x y) (@esym T y x). 
  LR - a lemma moving an operation from the left hand side of a relation to 
       the right hand side, like canLR: cancel g f -&gt; x = g y -&gt; f x = y.   
  RL - a lemma moving an operation from the right to the left, e.g., canRL. 
 Beware that the LR and RL orientations refer to an "apply" (back chaining) 
 usage; when using the same lemmas with "have" or "move" (forward chaining) 
 the directions will be reversed!.                                           
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>

<br/>
<span class="id" title="keyword">Delimit</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">fun_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">FUN</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">fun_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Notations for argument transpose  
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <a name="8f28bbd804547edd8de802d63ef85617"><span class="id" title="notation">&quot;</span></a>f ^~ y" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">f</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="var">y</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 10, <span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="var">format</span> "f ^~  y") : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="251a37e4f885e12e361f7995b3231c0d"><span class="id" title="notation">&quot;</span></a>@^~ x" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <span class="id" title="var">x</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 10, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="var">format</span> "@^~  x") : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Delimit</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">pair_scope</span> <span class="id" title="keyword">with</span> <span class="id" title="var">PAIR</span>.<br/>
<span class="id" title="keyword">Open</span> <span class="id" title="keyword">Scope</span> <span class="id" title="var">pair_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 Notations for pair/conjunction projections  
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <a name="c4877bbfe60d8f22b47ac99ace86216a"><span class="id" title="notation">&quot;</span></a>p .1" := (<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#fst"><span class="id" title="definition">fst</span></a> <span class="id" title="var">p</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 2, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="var">format</span> "p .1") : <span class="id" title="var">pair_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="f4827404159513e7fd691b60b7877737"><span class="id" title="notation">&quot;</span></a>p .2" := (<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#snd"><span class="id" title="definition">snd</span></a> <span class="id" title="var">p</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 2, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="var">format</span> "p .2") : <span class="id" title="var">pair_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">pair_of_and</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> (<span class="id" title="var">PandQ</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Q"><span class="id" title="variable">Q</span></a>) := <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#proj1"><span class="id" title="lemma">proj1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#PandQ"><span class="id" title="variable">PandQ</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#proj2"><span class="id" title="lemma">proj2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#PandQ"><span class="id" title="variable">PandQ</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="all_pair"><span class="id" title="definition">all_pair</span></a> <span class="id" title="var">I</span> <span class="id" title="var">T</span> <span class="id" title="var">U</span> (<span class="id" title="var">w</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">i</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#I"><span class="id" title="variable">I</span></a>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#U"><span class="id" title="variable">U</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a>) :=<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">i</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#c4877bbfe60d8f22b47ac99ace86216a"><span class="id" title="notation">(</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#c4877bbfe60d8f22b47ac99ace86216a"><span class="id" title="notation">).1</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <span class="id" title="keyword">fun</span> <span class="id" title="var">i</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f4827404159513e7fd691b60b7877737"><span class="id" title="notation">(</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#w"><span class="id" title="variable">w</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#f4827404159513e7fd691b60b7877737"><span class="id" title="notation">).2</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>.<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for evaluation  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;e .[ x ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 2, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="var">format</span> "e .[ x ]").<br/>

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;e .[ x1 , x2 , .. , xn ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 2, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "e '[ ' .[ x1 , '/'  x2 , '/'  .. , '/'  xn ] ']'").<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for subscripting and superscripting  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;s `_ i" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 3, <span class="id" title="var">i</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 2, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "s `_ i").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x ^-1" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 3, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="var">format</span> "x ^-1").<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for integer multipliers and exponents  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;x *+ n" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x *- n" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x ^+ n" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 29, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x ^- n" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 29, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for external multiplication.  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;x *: A" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;A :* x" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40).<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for set-theretic operations.  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;A :&amp;: B"  (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 48, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;A :|: B" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 52, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;a |: A" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 52, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;A :\: B" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;A :\ b" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for generated structures  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;&lt;&lt; A &gt;&gt;"  (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "&lt;&lt; A &gt;&gt;").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;&lt;[ a ] &gt;"  (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "&lt;[ a ] &gt;").<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for centralisers and centers.  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;''C' [ x ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">format</span> "''C' [ x ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;''C_' A [ x ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">A</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 2, <span class="id" title="var">format</span> "''C_' A [ x ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;''C' ( A )" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">format</span> "''C' ( A )").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;''C_' B ( A )"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">B</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 2, <span class="id" title="var">format</span> "''C_' B ( A )").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;''Z' ( A )" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">format</span> "''Z' ( A )").<br/>
</div>

<div class="doc">
 Compatibility with group action centraliser notation.  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;''C_' ( A ) [ x ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;''C_' ( B ) ( A )" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for Euclidean division and divisibility.  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;m %/ d" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;m %% d" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 40, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;m %| d" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;m = n %[mod d ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">n</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv ' m '/'  =  n '/'  %[mod  d ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;m == n %[mod d ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">n</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv ' m '/'  ==  n '/'  %[mod  d ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;m &lt;&gt; n %[mod d ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">n</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv ' m '/'  &lt;&gt;  n '/'  %[mod  d ] ']'").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;m != n %[mod d ]" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">n</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv ' m '/'  !=  n '/'  %[mod  d ] ']'").<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for derivatives.  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;a ^` " (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">format</span> "a ^` ").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;a ^` ( n )" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">format</span> "a ^` ( n )").<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for absolute value.  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span>  &quot;`| x |" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">format</span> "`| x |").<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for conditional comparison  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;x &lt;= y ?= 'iff' c" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">y</span>, <span class="id" title="var">c</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "x '[hv'  &lt;=  y '/'  ?=  'iff'  c ']'").<br/>

<br/>
</div>

<div class="doc">
 Reserved notation for cast comparison.  
</div>
<div class="code">
<span class="id" title="keyword">Reserved Notation</span> &quot;x &lt;= y :&gt; T" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x &gt;= y :&gt; T" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x &lt; y :&gt; T" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x &gt; y :&gt; T" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">y</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;x &lt;= y ?= 'iff' c :&gt; T" (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">y</span>, <span class="id" title="var">c</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "x '[hv'  &lt;=  y '/'  ?=  'iff'  c  :&gt; T ']'").<br/>

<br/>
</div>

<div class="doc">
 Complements on the option type constructor, used below to  
 encode partial functions.                                   
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="Option"><span class="id" title="module">Option</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="Option.apply"><span class="id" title="definition">apply</span></a> <span class="id" title="var">aT</span> <span class="id" title="var">rT</span> (<span class="id" title="var">f</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aT"><span class="id" title="variable">aT</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rT"><span class="id" title="variable">rT</span></a>) <span class="id" title="var">x</span> <span class="id" title="var">u</span> := <span class="id" title="keyword">if</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="var">is</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">y</span> <span class="id" title="keyword">then</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <span class="id" title="var">y</span> <span class="id" title="keyword">else</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="Option.default"><span class="id" title="definition">default</span></a> <span class="id" title="var">T</span> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Option.apply"><span class="id" title="definition">apply</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="Option.bind"><span class="id" title="definition">bind</span></a> <span class="id" title="var">aT</span> <span class="id" title="var">rT</span> (<span class="id" title="var">f</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aT"><span class="id" title="variable">aT</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rT"><span class="id" title="variable">rT</span></a>) := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Option.apply"><span class="id" title="definition">apply</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#None"><span class="id" title="constructor">None</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="Option.map"><span class="id" title="definition">map</span></a> <span class="id" title="var">aT</span> <span class="id" title="var">rT</span> (<span class="id" title="var">f</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aT"><span class="id" title="variable">aT</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rT"><span class="id" title="variable">rT</span></a>) := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Option.bind"><span class="id" title="definition">bind</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>)).<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Option"><span class="id" title="module">Option</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="oapp"><span class="id" title="abbreviation">oapp</span></a> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Option.apply"><span class="id" title="definition">Option.apply</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="odflt"><span class="id" title="abbreviation">odflt</span></a> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Option.default"><span class="id" title="definition">Option.default</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="obind"><span class="id" title="abbreviation">obind</span></a> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Option.bind"><span class="id" title="definition">Option.bind</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="omap"><span class="id" title="abbreviation">omap</span></a> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Option.map"><span class="id" title="definition">Option.map</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="some"><span class="id" title="abbreviation">some</span></a> := (@<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <span class="id" title="var">_</span>) (<span class="id" title="var">only</span> <span class="id" title="var">parsing</span>).<br/>

<br/>
</div>

<div class="doc">
 Shorthand for some basic equality lemmas.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Notation</span> <a name="erefl"><span class="id" title="abbreviation">erefl</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#refl_equal"><span class="id" title="abbreviation">refl_equal</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="ecast"><span class="id" title="abbreviation">ecast</span></a> <span class="id" title="var">i</span> <span class="id" title="var">T</span> <span class="id" title="var">e</span> <span class="id" title="var">x</span> := (<span class="id" title="keyword">let</span>: <span class="id" title="var">erefl</span> <span class="id" title="keyword">in</span> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <span class="id" title="var">i</span> := <span class="id" title="var">e</span> <span class="id" title="keyword">return</span> <span class="id" title="var">T</span> <span class="id" title="keyword">in</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Definition</span> <a name="esym"><span class="id" title="definition">esym</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#sym_eq"><span class="id" title="abbreviation">sym_eq</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="nesym"><span class="id" title="definition">nesym</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#sym_not_eq"><span class="id" title="abbreviation">sym_not_eq</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="etrans"><span class="id" title="definition">etrans</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#trans_eq"><span class="id" title="abbreviation">trans_eq</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="congr1"><span class="id" title="definition">congr1</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#f_equal"><span class="id" title="lemma">f_equal</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="congr2"><span class="id" title="definition">congr2</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#f_equal2"><span class="id" title="lemma">f_equal2</span></a>.<br/>
</div>

<div class="doc">
 Force at least one implicit when used as a view.  
</div>
<div class="code">

<br/>
</div>

<div class="doc">
 A predicate for singleton types.                                            
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="all_equal_to"><span class="id" title="definition">all_equal_to</span></a> <span class="id" title="var">T</span> (<span class="id" title="var">x0</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a>) := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssreflect.html#unkeyed"><span class="id" title="abbreviation">unkeyed</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x0"><span class="id" title="variable">x0</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="unitE"><span class="id" title="lemma">unitE</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#all_equal_to"><span class="id" title="definition">all_equal_to</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>.  <br/>

<br/>
</div>

<div class="doc">
 A generic wrapper type  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Structure</span> <a name="wrapped"><span class="id" title="record">wrapped</span></a> <span class="id" title="var">T</span> := <a name="Wrap"><span class="id" title="constructor">Wrap</span></a> {<a name="unwrap"><span class="id" title="projection">unwrap</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a>}.<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">wrap</span> <span class="id" title="var">T</span> <span class="id" title="var">x</span> := @<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Wrap"><span class="id" title="constructor">Wrap</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">
 Syntax for defining auxiliary recursive function.          
  Usage:                                                    
 Section FooDefinition.                                     
 Variables (g1 : T1) (g2 : T2).  (globals)                  
 Fixoint foo_auxiliary (a3 : T3) ... :=                     
        body, using [rec e3, ... ] for recursive calls       
 where " [ 'rec' a3 , a4 , ... ]" := foo_auxiliary.          
 Definition foo x y .. := [rec e1, ... ].                    
 + proofs about foo                                         
 End FooDefinition.                                          
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rec' a0 ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "[ 'rec'  a0 ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rec' a0 , a1 ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "[ 'rec'  a0 ,  a1 ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rec' a0 , a1 , a2 ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "[ 'rec'  a0 ,  a1 ,  a2 ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rec' a0 , a1 , a2 , a3 ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "[ 'rec'  a0 ,  a1 ,  a2 ,  a3 ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rec' a0 , a1 , a2 , a3 , a4 ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "[ 'rec'  a0 ,  a1 ,  a2 ,  a3 ,  a4 ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rec' a0 , a1 , a2 , a3 , a4 , a5 ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "[ 'rec'  a0 ,  a1 ,  a2 ,  a3 ,  a4 ,  a5 ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rec' a0 , a1 , a2 , a3 , a4 , a5 , a6 ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "[ 'rec'  a0 ,  a1 ,  a2 ,  a3 ,  a4 ,  a5 ,  a6 ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rec' a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'rec'  a0 ,  a1 ,  a2 ,  a3 ,  a4 ,  a5 ,  a6 ,  a7 ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rec' a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'rec'  a0 ,  a1 ,  a2 ,  a3 ,  a4 ,  a5 ,  a6 ,  a7 ,  a8 ]").<br/>
<span class="id" title="keyword">Reserved Notation</span> &quot;[ 'rec' a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 ]"<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;<span class="id" title="var">format</span> "[ 'rec'  a0 ,  a1 ,  a2 ,  a3 ,  a4 ,  a5 ,  a6 ,  a7 ,  a8 ,  a9 ]").<br/>

<br/>
</div>

<div class="doc">
 Definitions and notation for explicit functions with simplification,     
 i.e., which simpl and /= beta expand (this is complementary to nosimpl).  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="SimplFun"><span class="id" title="section">SimplFun</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> <a name="SimplFun.aT"><span class="id" title="variable">aT</span></a> <a name="SimplFun.rT"><span class="id" title="variable">rT</span></a> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">CoInductive</span> <a name="simpl_fun"><span class="id" title="inductive">simpl_fun</span></a> := <a name="SimplFun"><span class="id" title="constructor">SimplFun</span></a> <span class="id" title="var">of</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#SimplFun.aT"><span class="id" title="variable">aT</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#SimplFun.rT"><span class="id" title="variable">rT</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="fun_of_simpl"><span class="id" title="definition">fun_of_simpl</span></a> <span class="id" title="var">f</span> := <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="keyword">let</span>: <a class="idref" href="mathcomp.ssreflect.ssrfun.html#SimplFun"><span class="id" title="constructor">SimplFun</span></a> <span class="id" title="var">lam</span> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">lam</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#fun_of_simpl"><span class="id" title="definition">fun_of_simpl</span></a> : <span class="id" title="var">simpl_fun</span> &gt;-&gt; <span class="id" title="var">Funclass</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#SimplFun"><span class="id" title="section">SimplFun</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="ab3c12e44988714427613bf106696d73"><span class="id" title="notation">&quot;</span></a>[ 'fun' : T =&gt; E ]" := (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#SimplFun"><span class="id" title="constructor">SimplFun</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> : <span class="id" title="var">T</span> ⇒ <span class="id" title="var">E</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'fun' :  T  =&gt; '/ '  E ] ']'") : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="0bba0687209e799f52ace6d4b2c6d64a"><span class="id" title="notation">&quot;</span></a>[ 'fun' x =&gt; E ]" := (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#SimplFun"><span class="id" title="constructor">SimplFun</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">E</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'fun'  x  =&gt; '/ '  E ] ']'") : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">&quot;</span></a>[ 'fun' x : T =&gt; E ]" := (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#SimplFun"><span class="id" title="constructor">SimplFun</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> ⇒ <span class="id" title="var">E</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="651d7f5b7458080202d001cbfb600293"><span class="id" title="notation">&quot;</span></a>[ 'fun' x y =&gt; E ]" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#0bba0687209e799f52ace6d4b2c6d64a"><span class="id" title="notation">[</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#0bba0687209e799f52ace6d4b2c6d64a"><span class="id" title="notation">⇒</span></a> <span class="id" title="var">E</span><a class="idref" href="mathcomp.ssreflect.ssrfun.html#0bba0687209e799f52ace6d4b2c6d64a"><span class="id" title="notation">]</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "'[hv' [ 'fun'  x  y  =&gt; '/ '  E ] ']'") : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="80eeaa0aa73cb9ee573141c0cc91e592"><span class="id" title="notation">&quot;</span></a>[ 'fun' x y : T =&gt; E ]" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">[</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">:</span></a> <span class="id" title="var">T</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">⇒</span></a> <span class="id" title="var">E</span><a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">]</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="811a18b0df8e77226d7e286bcc583483"><span class="id" title="notation">&quot;</span></a>[ 'fun' ( x : T ) y =&gt; E ]" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#0bba0687209e799f52ace6d4b2c6d64a"><span class="id" title="notation">[</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#0bba0687209e799f52ace6d4b2c6d64a"><span class="id" title="notation">⇒</span></a> <span class="id" title="var">E</span><a class="idref" href="mathcomp.ssreflect.ssrfun.html#0bba0687209e799f52ace6d4b2c6d64a"><span class="id" title="notation">]</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="48ec9c02a5b8c7f307972e8209f0cec6"><span class="id" title="notation">&quot;</span></a>[ 'fun' x ( y : T ) =&gt; E ]" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">[</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">:</span></a> <span class="id" title="var">T</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">⇒</span></a> <span class="id" title="var">E</span><a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">]</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="b7730e6d681f745c37cbca48610e8676"><span class="id" title="notation">&quot;</span></a>[ 'fun' ( x : xT ) ( y : yT ) =&gt; E ]" :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">xT</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">[</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">:</span></a> <span class="id" title="var">yT</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">⇒</span></a> <span class="id" title="var">E</span><a class="idref" href="mathcomp.ssreflect.ssrfun.html#2322037eff9ef74f2498eb6baf8b6c77"><span class="id" title="notation">]</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 For delta functions in eqtype.v.  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="SimplFunDelta"><span class="id" title="definition">SimplFunDelta</span></a> <span class="id" title="var">aT</span> <span class="id" title="var">rT</span> (<span class="id" title="var">f</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aT"><span class="id" title="variable">aT</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aT"><span class="id" title="variable">aT</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rT"><span class="id" title="variable">rT</span></a>) := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#0bba0687209e799f52ace6d4b2c6d64a"><span class="id" title="notation">[</span></a><span class="id" title="keyword">fun</span> <span class="id" title="var">z</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#0bba0687209e799f52ace6d4b2c6d64a"><span class="id" title="notation">⇒</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <span class="id" title="var">z</span> <span class="id" title="var">z</span><a class="idref" href="mathcomp.ssreflect.ssrfun.html#0bba0687209e799f52ace6d4b2c6d64a"><span class="id" title="notation">]</span></a>.<br/>

<br/>
</div>

<div class="doc">
 Extensional equality, for unary and binary functions, including syntactic  
 sugar.                                                                      
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="ExtensionalEquality"><span class="id" title="section">ExtensionalEquality</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> <a name="ExtensionalEquality.A"><span class="id" title="variable">A</span></a> <a name="ExtensionalEquality.B"><span class="id" title="variable">B</span></a> <a name="ExtensionalEquality.C"><span class="id" title="variable">C</span></a> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="eqfun"><span class="id" title="definition">eqfun</span></a> (<span class="id" title="var">f</span> <span class="id" title="var">g</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#ExtensionalEquality.B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#ExtensionalEquality.A"><span class="id" title="variable">A</span></a>) : <span class="id" title="keyword">Prop</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="eqrel"><span class="id" title="definition">eqrel</span></a> (<span class="id" title="var">r</span> <span class="id" title="var">s</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#ExtensionalEquality.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#ExtensionalEquality.B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#ExtensionalEquality.A"><span class="id" title="variable">A</span></a>) : <span class="id" title="keyword">Prop</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#s"><span class="id" title="variable">s</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="frefl"><span class="id" title="lemma">frefl</span></a> <span class="id" title="var">f</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqfun"><span class="id" title="definition">eqfun</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a>.  <br/>
<span class="id" title="keyword">Lemma</span> <a name="fsym"><span class="id" title="lemma">fsym</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqfun"><span class="id" title="definition">eqfun</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqfun"><span class="id" title="definition">eqfun</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a>.  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="ftrans"><span class="id" title="lemma">ftrans</span></a> <span class="id" title="var">f</span> <span class="id" title="var">g</span> <span class="id" title="var">h</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqfun"><span class="id" title="definition">eqfun</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqfun"><span class="id" title="definition">eqfun</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqfun"><span class="id" title="definition">eqfun</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#h"><span class="id" title="variable">h</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="rrefl"><span class="id" title="lemma">rrefl</span></a> <span class="id" title="var">r</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqrel"><span class="id" title="definition">eqrel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#r"><span class="id" title="variable">r</span></a>.  <br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#ExtensionalEquality"><span class="id" title="section">ExtensionalEquality</span></a>.<br/>

<br/>
<span class="id" title="keyword">Type</span><span class="id" title="var">classes</span> <span class="id" title="keyword">Opaque</span> <span class="id" title="var">eqfun</span>.<br/>
<span class="id" title="keyword">Type</span><span class="id" title="var">classes</span> <span class="id" title="keyword">Opaque</span> <span class="id" title="var">eqrel</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">frefl</span> <span class="id" title="var">rrefl</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">&quot;</span></a>f1 =1 f2" := (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqfun"><span class="id" title="definition">eqfun</span></a> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="8dcd395a803cd8df68d4186c086daa17"><span class="id" title="notation">&quot;</span></a>f1 =1 f2 :&gt; A" := (<span class="id" title="var">f1</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">=1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">(</span></a><span class="id" title="var">f2</span> <a class="idref" href="mathcomp.ssreflect.ssreflect.html#4509b22bf26e3d6d771897e22bd8bc8f"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span><a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">f2</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>, <span class="id" title="var">A</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 90) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="86efabaf3ab961ac3d2bac35d2b3c35d"><span class="id" title="notation">&quot;</span></a>f1 =2 f2" := (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqrel"><span class="id" title="definition">eqrel</span></a> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="keyword">no</span> <span class="id" title="keyword">associativity</span>) : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="de57cb011c9f31a699e86db50948aacf"><span class="id" title="notation">&quot;</span></a>f1 =2 f2 :&gt; A" := (<span class="id" title="var">f1</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#86efabaf3ab961ac3d2bac35d2b3c35d"><span class="id" title="notation">=2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#86efabaf3ab961ac3d2bac35d2b3c35d"><span class="id" title="notation">(</span></a><span class="id" title="var">f2</span> <a class="idref" href="mathcomp.ssreflect.ssreflect.html#4509b22bf26e3d6d771897e22bd8bc8f"><span class="id" title="notation">:</span></a> <span class="id" title="var">A</span><a class="idref" href="mathcomp.ssreflect.ssrfun.html#86efabaf3ab961ac3d2bac35d2b3c35d"><span class="id" title="notation">)</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70, <span class="id" title="var">f2</span> <span class="id" title="tactic">at</span> <span class="id" title="var">next</span> <span class="id" title="keyword">level</span>, <span class="id" title="var">A</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 90) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="Composition"><span class="id" title="section">Composition</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> <a name="Composition.A"><span class="id" title="variable">A</span></a> <a name="Composition.B"><span class="id" title="variable">B</span></a> <a name="Composition.C"><span class="id" title="variable">C</span></a> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="funcomp"><span class="id" title="definition">funcomp</span></a> <span class="id" title="var">u</span> (<span class="id" title="var">f</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Composition.B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Composition.A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Composition.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Composition.B"><span class="id" title="variable">B</span></a>) <span class="id" title="var">x</span> := <span class="id" title="keyword">let</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>).<br/>
<span class="id" title="keyword">Definition</span> <a name="catcomp"><span class="id" title="definition">catcomp</span></a> <span class="id" title="var">u</span> <span class="id" title="var">g</span> <span class="id" title="var">f</span> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#funcomp"><span class="id" title="definition">funcomp</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="pcomp"><span class="id" title="definition">pcomp</span></a> (<span class="id" title="var">f</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Composition.B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Composition.A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">g</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Composition.C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Composition.B"><span class="id" title="variable">B</span></a>) <span class="id" title="var">x</span> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#obind"><span class="id" title="abbreviation">obind</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="eq_comp"><span class="id" title="lemma">eq_comp</span></a> <span class="id" title="var">f</span> <span class="id" title="var">f'</span> <span class="id" title="var">g</span> <span class="id" title="var">g'</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">=1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">=1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g'"><span class="id" title="variable">g'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#comp"><span class="id" title="abbreviation">comp</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">=1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#comp"><span class="id" title="abbreviation">comp</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g'"><span class="id" title="variable">g'</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Composition"><span class="id" title="section">Composition</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="comp"><span class="id" title="abbreviation">comp</span></a> := (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#funcomp"><span class="id" title="definition">funcomp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>).<br/>
<span class="id" title="keyword">Notation</span> <a name="20d5793f0b4411b7a9f5c73c05174fc9"><span class="id" title="notation">&quot;</span></a>@ 'comp'" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> ⇒ @<a class="idref" href="mathcomp.ssreflect.ssrfun.html#funcomp"><span class="id" title="definition">funcomp</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>).<br/>
<span class="id" title="keyword">Notation</span> <a name="1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">&quot;</span></a>f1 \o f2" := (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#comp"><span class="id" title="abbreviation">comp</span></a> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 50, <span class="id" title="var">format</span> "f1  \o '/ '  f2") : <span class="id" title="var">fun_scope</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="c42c5cb909c30537f9f6acfcf01cf7e1"><span class="id" title="notation">&quot;</span></a>f1 \; f2" := (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#catcomp"><span class="id" title="definition">catcomp</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> <span class="id" title="var">f1</span> <span class="id" title="var">f2</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 60, <span class="id" title="tactic">right</span> <span class="id" title="keyword">associativity</span>, <span class="id" title="var">format</span> "f1  \; '/ '  f2") : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">&quot;</span></a>[ 'eta' f ]" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">f</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">format</span> "[ 'eta'  f ]") : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="88f27261bb187bd4478d7606ce2605c1"><span class="id" title="notation">&quot;</span></a>'fun' =&gt; E" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">_</span> ⇒ <span class="id" title="var">E</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 200, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="id"><span class="id" title="abbreviation">id</span></a> := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>).<br/>
<span class="id" title="keyword">Notation</span> <a name="18cd0ece1c60c28b29a57eea4cb098ca"><span class="id" title="notation">&quot;</span></a>@ 'id' T" := (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">T</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 10, <span class="id" title="var">T</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">only</span> <span class="id" title="var">parsing</span>) : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="id_head"><span class="id" title="definition">id_head</span></a> <span class="id" title="var">T</span> <span class="id" title="var">u</span> <span class="id" title="var">x</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> := <span class="id" title="keyword">let</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="keyword">in</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="explicit_id_key"><span class="id" title="definition">explicit_id_key</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="idfun"><span class="id" title="abbreviation">idfun</span></a> := (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#id_head"><span class="id" title="definition">id_head</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>).<br/>
<span class="id" title="keyword">Notation</span> <a name="cc5a9586eb997be35b65ea12b2a985a9"><span class="id" title="notation">&quot;</span></a>@ 'idfun' T " := (@<a class="idref" href="mathcomp.ssreflect.ssrfun.html#id_head"><span class="id" title="definition">id_head</span></a> <span class="id" title="var">T</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#explicit_id_key"><span class="id" title="definition">explicit_id_key</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 10, <span class="id" title="var">T</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 8, <span class="id" title="var">format</span> "@ 'idfun'  T") : <span class="id" title="var">fun_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="phant_id"><span class="id" title="definition">phant_id</span></a> <span class="id" title="var">T1</span> <span class="id" title="var">T2</span> <span class="id" title="var">v1</span> <span class="id" title="var">v2</span> := <a class="idref" href="mathcomp.ssreflect.ssreflect.html#phantom"><span class="id" title="inductive">phantom</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T1"><span class="id" title="variable">T1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#v1"><span class="id" title="variable">v1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssreflect.html#phantom"><span class="id" title="inductive">phantom</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T2"><span class="id" title="variable">T2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#v2"><span class="id" title="variable">v2</span></a>.<br/>

<br/>
</div>

<div class="doc">
 Strong sigma types.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="Tag"><span class="id" title="section">Tag</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<a name="Tag.I"><span class="id" title="variable">I</span></a> : <span class="id" title="keyword">Type</span>) (<a name="Tag.i"><span class="id" title="variable">i</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#I"><span class="id" title="variable">I</span></a>) (<a name="Tag.T_"><span class="id" title="variable">T_</span></a> <a name="Tag.U_"><span class="id" title="variable">U_</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#I"><span class="id" title="variable">I</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="tag"><span class="id" title="definition">tag</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#projS1"><span class="id" title="abbreviation">projS1</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="tagged"><span class="id" title="definition">tagged</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">w</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.T_"><span class="id" title="variable">T_</span></a>(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#tag"><span class="id" title="definition">tag</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#w"><span class="id" title="variable">w</span></a>) := @<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#projS2"><span class="id" title="abbreviation">projS2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.I"><span class="id" title="variable">I</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">[</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">eta</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.T_"><span class="id" title="variable">T_</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">]</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="Tagged"><span class="id" title="definition">Tagged</span></a> <span class="id" title="var">x</span> := @<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#existS"><span class="id" title="abbreviation">existS</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.I"><span class="id" title="variable">I</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">[</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">eta</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.T_"><span class="id" title="variable">T_</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">]</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.i"><span class="id" title="variable">i</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="tag2"><span class="id" title="definition">tag2</span></a> (<span class="id" title="var">w</span> : @<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#sigT2"><span class="id" title="inductive">sigT2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.I"><span class="id" title="variable">I</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.T_"><span class="id" title="variable">T_</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.U_"><span class="id" title="variable">U_</span></a>) := <span class="id" title="keyword">let</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#existT2"><span class="id" title="constructor">existT2</span></a> <span class="id" title="var">i</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#w"><span class="id" title="variable">w</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">i</span>.<br/>
<span class="id" title="keyword">Definition</span> <a name="tagged2"><span class="id" title="definition">tagged2</span></a> <span class="id" title="var">w</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.T_"><span class="id" title="variable">T_</span></a>(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#tag2"><span class="id" title="definition">tag2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#w"><span class="id" title="variable">w</span></a>) := <span class="id" title="keyword">let</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#existT2"><span class="id" title="constructor">existT2</span></a> <span class="id" title="var">_</span> <span class="id" title="var">x</span> <span class="id" title="var">_</span> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#w"><span class="id" title="variable">w</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">x</span>.<br/>
<span class="id" title="keyword">Definition</span> <a name="tagged2'"><span class="id" title="definition">tagged2'</span></a> <span class="id" title="var">w</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.U_"><span class="id" title="variable">U_</span></a>(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#tag2"><span class="id" title="definition">tag2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#w"><span class="id" title="variable">w</span></a>) := <span class="id" title="keyword">let</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#existT2"><span class="id" title="constructor">existT2</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">y</span> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#w"><span class="id" title="variable">w</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Definition</span> <a name="Tagged2"><span class="id" title="definition">Tagged2</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> := @<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#existS2"><span class="id" title="abbreviation">existS2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.I"><span class="id" title="variable">I</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">[</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">eta</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.T_"><span class="id" title="variable">T_</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">]</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">[</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">eta</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.U_"><span class="id" title="variable">U_</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#3f6d75f5a9cb81b61e8423a7aac22056"><span class="id" title="notation">]</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag.i"><span class="id" title="variable">i</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tag"><span class="id" title="section">Tag</span></a>.<br/>

<br/>
<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tagged"><span class="id" title="definition">Tagged</span></a> [<span class="id" title="var">I</span> <span class="id" title="var">i</span>].<br/>
<span class="id" title="keyword">Implicit Arguments</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tagged2"><span class="id" title="definition">Tagged2</span></a> [<span class="id" title="var">I</span> <span class="id" title="var">i</span>].<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">tag_of_tag2</span> <span class="id" title="var">I</span> <span class="id" title="var">T_</span> <span class="id" title="var">U_</span> (<span class="id" title="var">w</span> : @<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#sigT2"><span class="id" title="inductive">sigT2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#I"><span class="id" title="variable">I</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T_"><span class="id" title="variable">T_</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#U_"><span class="id" title="variable">U_</span></a>) :=<br/>
&nbsp;&nbsp;<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tagged"><span class="id" title="definition">Tagged</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">i</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T_"><span class="id" title="variable">T_</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#d19c7eafd0e2d195d10df94b392087b5"><span class="id" title="notation">×</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#U_"><span class="id" title="variable">U_</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a>)%<span class="id" title="var">type</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">(</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#tagged2"><span class="id" title="definition">tagged2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">,</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#tagged2'"><span class="id" title="definition">tagged2'</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#w"><span class="id" title="variable">w</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#44400027531d4bc3f586a1997dc874c0"><span class="id" title="notation">)</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="all_tag"><span class="id" title="lemma">all_tag</span></a> <span class="id" title="var">I</span> <span class="id" title="var">T</span> <span class="id" title="var">U</span> :<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#I"><span class="id" title="variable">I</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#U"><span class="id" title="variable">U</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="var">y</span><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">{</span></a><span class="id" title="var">f</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">:</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">&amp;</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#U"><span class="id" title="variable">U</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> (<span class="id" title="var">f</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#50b5d8dd6be4fba768e35617e518ad76"><span class="id" title="notation">}</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="all_tag2"><span class="id" title="lemma">all_tag2</span></a> <span class="id" title="var">I</span> <span class="id" title="var">T</span> <span class="id" title="var">U</span> <span class="id" title="var">V</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">i</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#I"><span class="id" title="variable">I</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#e4098fb21bb0cc5ef8d3e3bf7391b88b"><span class="id" title="notation">{</span></a><span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#e4098fb21bb0cc5ef8d3e3bf7391b88b"><span class="id" title="notation">:</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#e4098fb21bb0cc5ef8d3e3bf7391b88b"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#U"><span class="id" title="variable">U</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a> <span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#e4098fb21bb0cc5ef8d3e3bf7391b88b"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#V"><span class="id" title="variable">V</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a> <span class="id" title="var">y</span><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#e4098fb21bb0cc5ef8d3e3bf7391b88b"><span class="id" title="notation">}</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#e4098fb21bb0cc5ef8d3e3bf7391b88b"><span class="id" title="notation">{</span></a><span class="id" title="var">f</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#e4098fb21bb0cc5ef8d3e3bf7391b88b"><span class="id" title="notation">:</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">i</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#e4098fb21bb0cc5ef8d3e3bf7391b88b"><span class="id" title="notation">&amp;</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">i</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#U"><span class="id" title="variable">U</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a> (<span class="id" title="var">f</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#e4098fb21bb0cc5ef8d3e3bf7391b88b"><span class="id" title="notation">&amp;</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">i</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#V"><span class="id" title="variable">V</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a> (<span class="id" title="var">f</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#e4098fb21bb0cc5ef8d3e3bf7391b88b"><span class="id" title="notation">}</span></a>.<br/>
 
<br/>
</div>

<div class="doc">
 Refinement types.  
<div class="paragraph"> </div>

  Prenex Implicits and renaming.  
</div>
<div class="code">
<span class="id" title="keyword">Notation</span> <a name="sval"><span class="id" title="abbreviation">sval</span></a> := (@<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
<span class="id" title="keyword">Notation</span> <a name="d31b79d69771a17d323737857541bcbd"><span class="id" title="notation">&quot;</span></a>@ 'sval'" := (@<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#proj1_sig"><span class="id" title="definition">proj1_sig</span></a>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 10, <span class="id" title="var">format</span> "@ 'sval'").<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="Sig"><span class="id" title="section">Sig</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<a name="Sig.T"><span class="id" title="variable">T</span></a> : <span class="id" title="keyword">Type</span>) (<a name="Sig.P"><span class="id" title="variable">P</span></a> <a name="Sig.Q"><span class="id" title="variable">Q</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="svalP"><span class="id" title="lemma">svalP</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#sig"><span class="id" title="inductive">sig</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Sig.P"><span class="id" title="variable">P</span></a>) : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Sig.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#sval"><span class="id" title="abbreviation">sval</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a>).  <br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="s2val"><span class="id" title="definition">s2val</span></a> (<span class="id" title="var">u</span> : <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#sig2"><span class="id" title="inductive">sig2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Sig.P"><span class="id" title="variable">P</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Sig.Q"><span class="id" title="variable">Q</span></a>) := <span class="id" title="keyword">let</span>: <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#exist2"><span class="id" title="constructor">exist2</span></a> <span class="id" title="var">x</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a> <span class="id" title="keyword">in</span> <span class="id" title="var">x</span>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="s2valP"><span class="id" title="lemma">s2valP</span></a> <span class="id" title="var">u</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Sig.P"><span class="id" title="variable">P</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#s2val"><span class="id" title="definition">s2val</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a>).  <br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="s2valP'"><span class="id" title="lemma">s2valP'</span></a> <span class="id" title="var">u</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Sig.Q"><span class="id" title="variable">Q</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#s2val"><span class="id" title="definition">s2val</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a>).  <br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Sig"><span class="id" title="section">Sig</span></a>.<br/>

<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">tag_of_sig</span> <span class="id" title="var">I</span> <span class="id" title="var">P</span> (<span class="id" title="var">u</span> : @<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#sig"><span class="id" title="inductive">sig</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#I"><span class="id" title="variable">I</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#P"><span class="id" title="variable">P</span></a>) := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Tagged"><span class="id" title="definition">Tagged</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#P"><span class="id" title="variable">P</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#svalP"><span class="id" title="lemma">svalP</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a>).<br/>

<br/>
<span class="id" title="keyword">Coercion</span> <span class="id" title="var">sig_of_sig2</span> <span class="id" title="var">I</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> (<span class="id" title="var">u</span> : @<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#sig2"><span class="id" title="inductive">sig2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#I"><span class="id" title="variable">I</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Q"><span class="id" title="variable">Q</span></a>) :=<br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#exist"><span class="id" title="constructor">exist</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">i</span> ⇒ <a class="idref" href="mathcomp.ssreflect.ssrfun.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d82a7d96d3659d805ffe732283716822"><span class="id" title="notation">∧</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#i"><span class="id" title="variable">i</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#s2val"><span class="id" title="definition">s2val</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#conj"><span class="id" title="constructor">conj</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#s2valP"><span class="id" title="lemma">s2valP</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#s2valP'"><span class="id" title="lemma">s2valP'</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#u"><span class="id" title="variable">u</span></a>)).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="all_sig"><span class="id" title="lemma">all_sig</span></a> <span class="id" title="var">I</span> <span class="id" title="var">T</span> <span class="id" title="var">P</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#I"><span class="id" title="variable">I</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">{</span></a><span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">:</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">|</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="var">y</span><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">}</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">{</span></a><span class="id" title="var">f</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">:</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">|</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> (<span class="id" title="var">f</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#72ca3fac4636a1b19c963b12162882cf"><span class="id" title="notation">}</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="all_sig2"><span class="id" title="lemma">all_sig2</span></a> <span class="id" title="var">I</span> <span class="id" title="var">T</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#I"><span class="id" title="variable">I</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#602b9943a639fb973abed6e2c7854421"><span class="id" title="notation">{</span></a><span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#602b9943a639fb973abed6e2c7854421"><span class="id" title="notation">:</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#602b9943a639fb973abed6e2c7854421"><span class="id" title="notation">|</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="var">y</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#602b9943a639fb973abed6e2c7854421"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="var">y</span><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#602b9943a639fb973abed6e2c7854421"><span class="id" title="notation">}</span></a><a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#602b9943a639fb973abed6e2c7854421"><span class="id" title="notation">{</span></a><span class="id" title="var">f</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#602b9943a639fb973abed6e2c7854421"><span class="id" title="notation">:</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#602b9943a639fb973abed6e2c7854421"><span class="id" title="notation">|</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> (<span class="id" title="var">f</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#602b9943a639fb973abed6e2c7854421"><span class="id" title="notation">&amp;</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> (<span class="id" title="var">f</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Specif.html#602b9943a639fb973abed6e2c7854421"><span class="id" title="notation">}</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Section</span> <a name="Morphism"><span class="id" title="section">Morphism</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<a name="Morphism.aT"><span class="id" title="variable">aT</span></a> <a name="Morphism.rT"><span class="id" title="variable">rT</span></a> <a name="Morphism.sT"><span class="id" title="variable">sT</span></a> : <span class="id" title="keyword">Type</span>) (<a name="Morphism.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aT"><span class="id" title="variable">aT</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rT"><span class="id" title="variable">rT</span></a>).<br/>

<br/>
</div>

<div class="doc">
 Morphism property for unary and binary functions  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="morphism_1"><span class="id" title="definition">morphism_1</span></a> <span class="id" title="var">aF</span> <span class="id" title="var">rF</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#aF"><span class="id" title="variable">aF</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rF"><span class="id" title="variable">rF</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>).<br/>
<span class="id" title="keyword">Definition</span> <a name="morphism_2"><span class="id" title="definition">morphism_2</span></a> <span class="id" title="var">aOp</span> <span class="id" title="var">rOp</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#aOp"><span class="id" title="variable">aOp</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rOp"><span class="id" title="variable">rOp</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>).<br/>

<br/>
</div>

<div class="doc">
 Homomorphism property for unary and binary relations  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="homomorphism_1"><span class="id" title="definition">homomorphism_1</span></a> (<span class="id" title="var">aP</span> <span class="id" title="var">rP</span> : <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>) := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aP"><span class="id" title="variable">aP</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rP"><span class="id" title="variable">rP</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>).<br/>
<span class="id" title="keyword">Definition</span> <a name="homomorphism_2"><span class="id" title="definition">homomorphism_2</span></a> (<span class="id" title="var">aR</span> <span class="id" title="var">rR</span> : <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aR"><span class="id" title="variable">aR</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rR"><span class="id" title="variable">rR</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>).<br/>

<br/>
</div>

<div class="doc">
 Stability property for unary and binary relations  
</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <a name="monomorphism_1"><span class="id" title="definition">monomorphism_1</span></a> (<span class="id" title="var">aP</span> <span class="id" title="var">rP</span> : <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.sT"><span class="id" title="variable">sT</span></a>) := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rP"><span class="id" title="variable">rP</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aP"><span class="id" title="variable">aP</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="monomorphism_2"><span class="id" title="definition">monomorphism_2</span></a> (<span class="id" title="var">aR</span> <span class="id" title="var">rR</span> : <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.sT"><span class="id" title="variable">sT</span></a>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rR"><span class="id" title="variable">rR</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aR"><span class="id" title="variable">aR</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Morphism"><span class="id" title="section">Morphism</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="59b5bb4add86e1e9ecbe874e74b2216e"><span class="id" title="notation">&quot;</span></a>{ 'morph' f : x / a &gt;-&gt; r }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#morphism_1"><span class="id" title="definition">morphism_1</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">r</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'morph'  f  :  x  /  a  &gt;-&gt;  r }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="c3c88e2b30b681cd767a54649faf5973"><span class="id" title="notation">&quot;</span></a>{ 'morph' f : x / a }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#morphism_1"><span class="id" title="definition">morphism_1</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'morph'  f  :  x  /  a }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="a0fd72584f326d7220475d01d3fceccd"><span class="id" title="notation">&quot;</span></a>{ 'morph' f : x y / a &gt;-&gt; r }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#morphism_2"><span class="id" title="definition">morphism_2</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">r</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'morph'  f  :  x  y  /  a  &gt;-&gt;  r }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="3014e73af2a90fd800d8681479d76336"><span class="id" title="notation">&quot;</span></a>{ 'morph' f : x y / a }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#morphism_2"><span class="id" title="definition">morphism_2</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'morph'  f  :  x  y  /  a }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="8e4521b8cc16b7bfcb3b5106bd4e17cc"><span class="id" title="notation">&quot;</span></a>{ 'homo' f : x / a &gt;-&gt; r }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#homomorphism_1"><span class="id" title="definition">homomorphism_1</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">r</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'homo'  f  :  x  /  a  &gt;-&gt;  r }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="decc5ade2c2879607bbea0935785bb5f"><span class="id" title="notation">&quot;</span></a>{ 'homo' f : x / a }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#homomorphism_1"><span class="id" title="definition">homomorphism_1</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'homo'  f  :  x  /  a }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="f95d8eadb7771a72d2066af1aebc7110"><span class="id" title="notation">&quot;</span></a>{ 'homo' f : x y / a &gt;-&gt; r }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#homomorphism_2"><span class="id" title="definition">homomorphism_2</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">r</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'homo'  f  :  x  y  /  a  &gt;-&gt;  r }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="bf2e58b992e0391262bcf1e3bb7b0fc0"><span class="id" title="notation">&quot;</span></a>{ 'homo' f : x y / a }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#homomorphism_2"><span class="id" title="definition">homomorphism_2</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'homo'  f  :  x  y  /  a }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="9caa0748cced1c5dad561bd5f28bd7db"><span class="id" title="notation">&quot;</span></a>{ 'homo' f : x y /~ a }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#homomorphism_2"><span class="id" title="definition">homomorphism_2</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'homo'  f  :  x  y  /~  a }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="fcecf6c7c5b99f975a4e95451ce580e5"><span class="id" title="notation">&quot;</span></a>{ 'mono' f : x / a &gt;-&gt; r }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#monomorphism_1"><span class="id" title="definition">monomorphism_1</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">r</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'mono'  f  :  x  /  a  &gt;-&gt;  r }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="69ee97879e4a4ae19a99125173c5741e"><span class="id" title="notation">&quot;</span></a>{ 'mono' f : x / a }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#monomorphism_1"><span class="id" title="definition">monomorphism_1</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'mono'  f  :  x  /  a }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="aed5e67b67900c70888bda2ff72f1de4"><span class="id" title="notation">&quot;</span></a>{ 'mono' f : x y / a &gt;-&gt; r }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#monomorphism_2"><span class="id" title="definition">monomorphism_2</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">r</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'mono'  f  :  x  y  /  a  &gt;-&gt;  r }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="cedeb4d71ab31ea655ad3d06a9c296b3"><span class="id" title="notation">&quot;</span></a>{ 'mono' f : x y / a }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#monomorphism_2"><span class="id" title="definition">monomorphism_2</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'mono'  f  :  x  y  /  a }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="744665b4ecc83382846c028dbdceae50"><span class="id" title="notation">&quot;</span></a>{ 'mono' f : x y /~ a }" :=<br/>
&nbsp;&nbsp;(<a class="idref" href="mathcomp.ssreflect.ssrfun.html#monomorphism_2"><span class="id" title="definition">monomorphism_2</span></a> <span class="id" title="var">f</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> <span class="id" title="var">x</span> ⇒ <span class="id" title="var">a</span>) (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <span class="id" title="var">a</span>))<br/>
&nbsp;&nbsp;(<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 0, <span class="id" title="var">f</span> <span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 99, <span class="id" title="var">x</span> <span class="id" title="var">ident</span>, <span class="id" title="var">y</span> <span class="id" title="var">ident</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">format</span> "{ 'mono'  f  :  x  y  /~  a }") : <span class="id" title="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
 In an intuitionistic setting, we have two degrees of injectivity. The     
 weaker one gives only simplification, and the strong one provides a left  
 inverse (we show in `fintype' that they coincide for finite types).       
 We also define an intermediate version where the left inverse is only a   
 partial function.                                                          
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="Injections"><span class="id" title="section">Injections</span></a>.<br/>

<br/>
</div>

<div class="doc">
 rT must come first so we can use @ to mitigate the Coq 1st order   
 unification bug (e..g., Coq can't infer rT from a "cancel" lemma).  
</div>
<div class="code">
<span class="id" title="keyword">Variables</span> (<a name="Injections.rT"><span class="id" title="variable">rT</span></a> <a name="Injections.aT"><span class="id" title="variable">aT</span></a> : <span class="id" title="keyword">Type</span>) (<a name="Injections.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#aT"><span class="id" title="variable">aT</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#rT"><span class="id" title="variable">rT</span></a>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="injective"><span class="id" title="definition">injective</span></a> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x1</span> <span class="id" title="var">x2</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Injections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x1"><span class="id" title="variable">x1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Injections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x2"><span class="id" title="variable">x2</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x1"><span class="id" title="variable">x1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x2"><span class="id" title="variable">x2</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="cancel"><span class="id" title="definition">cancel</span></a> <span class="id" title="var">g</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Injections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="pcancel"><span class="id" title="definition">pcancel</span></a> <span class="id" title="var">g</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#Injections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="ocancel"><span class="id" title="definition">ocancel</span></a> (<span class="id" title="var">g</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Injections.aT"><span class="id" title="variable">aT</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#option"><span class="id" title="inductive">option</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Injections.rT"><span class="id" title="variable">rT</span></a>) <span class="id" title="var">h</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#oapp"><span class="id" title="abbreviation">oapp</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="can_pcan"><span class="id" title="lemma">can_pcan</span></a> <span class="id" title="var">g</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#pcancel"><span class="id" title="definition">pcancel</span></a> (<span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>)).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="pcan_inj"><span class="id" title="lemma">pcan_inj</span></a> <span class="id" title="var">g</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#pcancel"><span class="id" title="definition">pcancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="can_inj"><span class="id" title="lemma">can_inj</span></a> <span class="id" title="var">g</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="canLR"><span class="id" title="lemma">canLR</span></a> <span class="id" title="var">g</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Injections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="canRL"><span class="id" title="lemma">canRL</span></a> <span class="id" title="var">g</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Injections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Injections"><span class="id" title="section">Injections</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Some_inj"><span class="id" title="lemma">Some_inj</span></a> {<span class="id" title="var">T</span>} : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> (@<a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Datatypes.html#Some"><span class="id" title="constructor">Some</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a>).  <br/>

<br/>
</div>

<div class="doc">
 cancellation lemmas for dependent type casts.                              
</div>
<div class="code">
<span class="id" title="keyword">Lemma</span> <a name="esymK"><span class="id" title="lemma">esymK</span></a> <span class="id" title="var">T</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> (@<a class="idref" href="mathcomp.ssreflect.ssrfun.html#esym"><span class="id" title="definition">esym</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>) (@<a class="idref" href="mathcomp.ssreflect.ssrfun.html#esym"><span class="id" title="definition">esym</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="etrans_id"><span class="id" title="lemma">etrans_id</span></a> <span class="id" title="var">T</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> (<span class="id" title="var">eqxy</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#8f9364556521ebb498093f28eea2240f"><span class="id" title="notation">:&gt;</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#T"><span class="id" title="variable">T</span></a>) : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#etrans"><span class="id" title="definition">etrans</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#erefl"><span class="id" title="abbreviation">erefl</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqxy"><span class="id" title="variable">eqxy</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#eqxy"><span class="id" title="variable">eqxy</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Section</span> <a name="InjectionsTheory"><span class="id" title="section">InjectionsTheory</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<a name="InjectionsTheory.A"><span class="id" title="variable">A</span></a> <a name="InjectionsTheory.B"><span class="id" title="variable">B</span></a> <a name="InjectionsTheory.C"><span class="id" title="variable">C</span></a> : <span class="id" title="keyword">Type</span>) (<a name="InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a name="InjectionsTheory.g"><span class="id" title="variable">g</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#A"><span class="id" title="variable">A</span></a>) (<a name="InjectionsTheory.h"><span class="id" title="variable">h</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#B"><span class="id" title="variable">B</span></a>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="inj_id"><span class="id" title="lemma">inj_id</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#18cd0ece1c60c28b29a57eea4cb098ca"><span class="id" title="notation">@</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#18cd0ece1c60c28b29a57eea4cb098ca"><span class="id" title="notation">id</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.A"><span class="id" title="variable">A</span></a>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="inj_can_sym"><span class="id" title="lemma">inj_can_sym</span></a> <span class="id" title="var">f'</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="inj_comp"><span class="id" title="lemma">inj_comp</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">\</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">o</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.h"><span class="id" title="variable">h</span></a>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="can_comp"><span class="id" title="lemma">can_comp</span></a> <span class="id" title="var">f'</span> <span class="id" title="var">h'</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.h"><span class="id" title="variable">h</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#h'"><span class="id" title="variable">h'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">\</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">o</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.h"><span class="id" title="variable">h</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#h'"><span class="id" title="variable">h'</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">\</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">o</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="pcan_pcomp"><span class="id" title="lemma">pcan_pcomp</span></a> <span class="id" title="var">f'</span> <span class="id" title="var">h'</span> :<br/>
&nbsp;&nbsp;<a class="idref" href="mathcomp.ssreflect.ssrfun.html#pcancel"><span class="id" title="definition">pcancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#pcancel"><span class="id" title="definition">pcancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.h"><span class="id" title="variable">h</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#h'"><span class="id" title="variable">h'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#pcancel"><span class="id" title="definition">pcancel</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">\</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">o</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.h"><span class="id" title="variable">h</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#pcomp"><span class="id" title="definition">pcomp</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#h'"><span class="id" title="variable">h'</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a>).<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="eq_inj"><span class="id" title="lemma">eq_inj</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">=1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.g"><span class="id" title="variable">g</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="eq_can"><span class="id" title="lemma">eq_can</span></a> <span class="id" title="var">f'</span> <span class="id" title="var">g'</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">=1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">=1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g'"><span class="id" title="variable">g'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g'"><span class="id" title="variable">g'</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="inj_can_eq"><span class="id" title="lemma">inj_can_eq</span></a> <span class="id" title="var">f'</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">=1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory.g"><span class="id" title="variable">g</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#InjectionsTheory"><span class="id" title="section">InjectionsTheory</span></a>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="Bijections"><span class="id" title="section">Bijections</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<a name="Bijections.A"><span class="id" title="variable">A</span></a> <a name="Bijections.B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>) (<a name="Bijections.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#A"><span class="id" title="variable">A</span></a>).<br/>

<br/>
<span class="id" title="keyword">CoInductive</span> <a name="bijective"><span class="id" title="inductive">bijective</span></a> : <span class="id" title="keyword">Prop</span> := <a name="Bijective"><span class="id" title="constructor">Bijective</span></a> <span class="id" title="var">g</span> <span class="id" title="var">of</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Bijections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> &amp; <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Bijections.f"><span class="id" title="variable">f</span></a>.<br/>

<br/>
<span class="id" title="keyword">Hypothesis</span> <a name="Bijections.bijf"><span class="id" title="variable">bijf</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#bijective"><span class="id" title="inductive">bijective</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="bij_inj"><span class="id" title="lemma">bij_inj</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Bijections.f"><span class="id" title="variable">f</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="bij_can_sym"><span class="id" title="lemma">bij_can_sym</span></a> <span class="id" title="var">f'</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Bijections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#df1ced36fc33ce188051218bca314374"><span class="id" title="notation">↔</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Bijections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="bij_can_eq"><span class="id" title="lemma">bij_can_eq</span></a> <span class="id" title="var">f'</span> <span class="id" title="var">f''</span> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Bijections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Bijections.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f''"><span class="id" title="variable">f''</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">=1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f''"><span class="id" title="variable">f''</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Bijections"><span class="id" title="section">Bijections</span></a>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="BijectionsTheory"><span class="id" title="section">BijectionsTheory</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<a name="BijectionsTheory.A"><span class="id" title="variable">A</span></a> <a name="BijectionsTheory.B"><span class="id" title="variable">B</span></a> <a name="BijectionsTheory.C"><span class="id" title="variable">C</span></a> : <span class="id" title="keyword">Type</span>) (<a name="BijectionsTheory.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#A"><span class="id" title="variable">A</span></a>) (<a name="BijectionsTheory.h"><span class="id" title="variable">h</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#C"><span class="id" title="variable">C</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#B"><span class="id" title="variable">B</span></a>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="eq_bij"><span class="id" title="lemma">eq_bij</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#bijective"><span class="id" title="inductive">bijective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#BijectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">g</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#BijectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#2500d48ed8e862ccfda98a44dff88963"><span class="id" title="notation">=1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#bijective"><span class="id" title="inductive">bijective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#g"><span class="id" title="variable">g</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">Lemma</span> <a name="bij_comp"><span class="id" title="lemma">bij_comp</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#bijective"><span class="id" title="inductive">bijective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#BijectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#bijective"><span class="id" title="inductive">bijective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#BijectionsTheory.h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#bijective"><span class="id" title="inductive">bijective</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#BijectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">\</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#1b4394c5c1740ef3dc9e4224084970bb"><span class="id" title="notation">o</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#BijectionsTheory.h"><span class="id" title="variable">h</span></a>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="bij_can_bij"><span class="id" title="lemma">bij_can_bij</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#bijective"><span class="id" title="inductive">bijective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#BijectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">∀</span> <span class="id" title="var">f'</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#BijectionsTheory.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#bijective"><span class="id" title="inductive">bijective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#f'"><span class="id" title="variable">f'</span></a>.<br/>
 
<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#BijectionsTheory"><span class="id" title="section">BijectionsTheory</span></a>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="Involutions"><span class="id" title="section">Involutions</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<a name="Involutions.A"><span class="id" title="variable">A</span></a> : <span class="id" title="keyword">Type</span>) (<a name="Involutions.f"><span class="id" title="variable">f</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#A"><span class="id" title="variable">A</span></a>).<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="involutive"><span class="id" title="definition">involutive</span></a> := <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Involutions.f"><span class="id" title="variable">f</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Involutions.f"><span class="id" title="variable">f</span></a>.<br/>

<br/>
<span class="id" title="keyword">Hypothesis</span> <a name="Involutions.Hf"><span class="id" title="variable">Hf</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#involutive"><span class="id" title="definition">involutive</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="inv_inj"><span class="id" title="lemma">inv_inj</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Involutions.f"><span class="id" title="variable">f</span></a>.  <br/>
<span class="id" title="keyword">Lemma</span> <a name="inv_bij"><span class="id" title="lemma">inv_bij</span></a> : <a class="idref" href="mathcomp.ssreflect.ssrfun.html#bijective"><span class="id" title="inductive">bijective</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Involutions.f"><span class="id" title="variable">f</span></a>.  <br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#Involutions"><span class="id" title="section">Involutions</span></a>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="OperationProperties"><span class="id" title="section">OperationProperties</span></a>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> <a name="OperationProperties.S"><span class="id" title="variable">S</span></a> <a name="OperationProperties.T"><span class="id" title="variable">T</span></a> <a name="OperationProperties.R"><span class="id" title="variable">R</span></a> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="OperationProperties.SopTisR"><span class="id" title="section">SopTisR</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">op</span> :  <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.S"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.R"><span class="id" title="variable">R</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="left_inverse"><span class="id" title="definition">left_inverse</span></a> <span class="id" title="var">e</span> <span class="id" title="var">inv</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#inv"><span class="id" title="variable">inv</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#e"><span class="id" title="variable">e</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="right_inverse"><span class="id" title="definition">right_inverse</span></a> <span class="id" title="var">e</span> <span class="id" title="var">inv</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#inv"><span class="id" title="variable">inv</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#e"><span class="id" title="variable">e</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="left_injective"><span class="id" title="definition">left_injective</span></a> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#8f28bbd804547edd8de802d63ef85617"><span class="id" title="notation">^~</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>).<br/>
<span class="id" title="keyword">Definition</span> <a name="right_injective"><span class="id" title="definition">right_injective</span></a> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">y</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#injective"><span class="id" title="definition">injective</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>).<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.SopTisR"><span class="id" title="section">SopTisR</span></a>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="OperationProperties.SopTisS"><span class="id" title="section">SopTisS</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">op</span> :  <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.S"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.S"><span class="id" title="variable">S</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="right_id"><span class="id" title="definition">right_id</span></a> <span class="id" title="var">e</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="left_zero"><span class="id" title="definition">left_zero</span></a> <span class="id" title="var">z</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="right_commutative"><span class="id" title="definition">right_commutative</span></a> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="left_distributive"><span class="id" title="definition">left_distributive</span></a> <span class="id" title="var">op</span> <span class="id" title="var">add</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#add"><span class="id" title="variable">add</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#add"><span class="id" title="variable">add</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>).<br/>
<span class="id" title="keyword">Definition</span> <a name="right_loop"><span class="id" title="definition">right_loop</span></a> <span class="id" title="var">inv</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">y</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#8f28bbd804547edd8de802d63ef85617"><span class="id" title="notation">^~</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#8f28bbd804547edd8de802d63ef85617"><span class="id" title="notation">^~</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#8f28bbd804547edd8de802d63ef85617"><span class="id" title="notation">(</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#inv"><span class="id" title="variable">inv</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#8f28bbd804547edd8de802d63ef85617"><span class="id" title="notation">)</span></a>).<br/>
<span class="id" title="keyword">Definition</span> <a name="rev_right_loop"><span class="id" title="definition">rev_right_loop</span></a> <span class="id" title="var">inv</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">y</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#8f28bbd804547edd8de802d63ef85617"><span class="id" title="notation">^~</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#8f28bbd804547edd8de802d63ef85617"><span class="id" title="notation">(</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#inv"><span class="id" title="variable">inv</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#8f28bbd804547edd8de802d63ef85617"><span class="id" title="notation">)</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a><a class="idref" href="mathcomp.ssreflect.ssrfun.html#8f28bbd804547edd8de802d63ef85617"><span class="id" title="notation">^~</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>).<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.SopTisS"><span class="id" title="section">SopTisS</span></a>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="OperationProperties.SopTisT"><span class="id" title="section">SopTisT</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">op</span> :  <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.S"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="left_id"><span class="id" title="definition">left_id</span></a> <span class="id" title="var">e</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="right_zero"><span class="id" title="definition">right_zero</span></a> <span class="id" title="var">z</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="left_commutative"><span class="id" title="definition">left_commutative</span></a> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>).<br/>
<span class="id" title="keyword">Definition</span> <a name="right_distributive"><span class="id" title="definition">right_distributive</span></a> <span class="id" title="var">op</span> <span class="id" title="var">add</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#add"><span class="id" title="variable">add</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#add"><span class="id" title="variable">add</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>).<br/>
<span class="id" title="keyword">Definition</span> <a name="left_loop"><span class="id" title="definition">left_loop</span></a> <span class="id" title="var">inv</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#inv"><span class="id" title="variable">inv</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>)).<br/>
<span class="id" title="keyword">Definition</span> <a name="rev_left_loop"><span class="id" title="definition">rev_left_loop</span></a> <span class="id" title="var">inv</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#cancel"><span class="id" title="definition">cancel</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#inv"><span class="id" title="variable">inv</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>)) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>).<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.SopTisT"><span class="id" title="section">SopTisT</span></a>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="OperationProperties.SopSisT"><span class="id" title="section">SopSisT</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">op</span> :  <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.S"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.S"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="self_inverse"><span class="id" title="definition">self_inverse</span></a> <span class="id" title="var">e</span> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#e"><span class="id" title="variable">e</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="commutative"><span class="id" title="definition">commutative</span></a> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.SopSisT"><span class="id" title="section">SopSisT</span></a>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="OperationProperties.SopSisS"><span class="id" title="section">SopSisS</span></a>.<br/>
<span class="id" title="keyword">Implicit</span> <span class="id" title="keyword">Type</span> <span class="id" title="var">op</span> :  <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.S"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.S"><span class="id" title="variable">S</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#d43e996736952df71ebeeae74d10a287"><span class="id" title="notation">→</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.S"><span class="id" title="variable">S</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="idempotent"><span class="id" title="definition">idempotent</span></a> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="associative"><span class="id" title="definition">associative</span></a> <span class="id" title="var">op</span> := <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op"><span class="id" title="variable">op</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="interchange"><span class="id" title="definition">interchange</span></a> <span class="id" title="var">op1</span> <span class="id" title="var">op2</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> <span class="id" title="var">t</span>, <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op1"><span class="id" title="variable">op1</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op2"><span class="id" title="variable">op2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op2"><span class="id" title="variable">op2</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#t"><span class="id" title="variable">t</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/8.5beta3/stdlib/Coq.Init.Logic.html#1c39bf18749e5cc609e83c0a0ba5a372"><span class="id" title="notation">=</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#op2"><span class="id" title="variable">op2</span></a> (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op1"><span class="id" title="variable">op1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#z"><span class="id" title="variable">z</span></a>) (<a class="idref" href="mathcomp.ssreflect.ssrfun.html#op1"><span class="id" title="variable">op1</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#t"><span class="id" title="variable">t</span></a>).<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties.SopSisS"><span class="id" title="section">SopSisS</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="mathcomp.ssreflect.ssrfun.html#OperationProperties"><span class="id" title="section">OperationProperties</span></a>.<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>